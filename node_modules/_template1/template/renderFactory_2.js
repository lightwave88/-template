const GModules = require('../Gmodules.js');

// 從文本解析出 tag
const $TagTools = require('./tagTools_3.js');

// output 模組
const $OutputModule = require('./output_2.js');

// 應用函式模組
const $FunctionModule = require('./functions_2.js');

const $Filter = require('./filter_2.js');

const $SystemInfo = require('./systemInfo_1.js');


////////////////////////////////////////////////////////////////////////////////
//
//
// renderFunction 背後的處理著
//
////////////////////////////////////////////////////////////////////////////////

// 模板內的全域變數
// Data: 資料
// Out: 輸出模組
// Fun: 應用函式
// Path: 路徑資訊
const GlobalVariableKey = ["Data", "Output", "Fun", "Path", "Filter", "Variable"];

class RenderFactory {


    // 產生一個 render 函式
    static getRenderFunction(content, options) {
        // debugger;
        const core = new RenderFactory(content, options);
        //-----------------------
        const fn = (function (data) {
            // debugger;

            let res = this.main(data);
            return res;
        }).bind(core);
        //-----------------------
        // 解析方法採用何種方式
        fn.setAsync = function (async) {
            core.setAsync(async);
        };

        // 設定模板內的路徑資訊
        fn.setPath = function (name, path) {
            core.setPath(name, path);
        };

        // 設定 include.rootPath
        fn.setIncludepath = function (path) {
            core.setIncludepath(path);
        };

        // 綁定模板內的對象
        fn.setBind = function (obj) {
            core.setBind(obj);
        };

        // 設定模板內的全域變數
        fn.setVariable = function (k, v) {
            core.setVariable(k, v);
        };

        // 設定 injectMode 的分組
        fn.setGroup = function (moduleGroup) {
            core.setGroup(moduleGroup);
        };

        /*
            options = {
                bind:
                includePath:
                path:
                variable:
                async:
                group:
            }
        */
        fn.setOption = function (k, v) {
            core.setOption(k, v);
        };

        return fn;
    }
    //----------------------------

    // options: {async: , path: , moduleName: , includepath: , bind:}
    constructor(content, options) {
        this.systemInfo;

        // 模板會用到的資料
        this.data = {};

        // 使用者選項
        this.options = {
            //模板內運作方式
            async: false,
            // 模板內的全域者
            bind: {},
            // 模板要用的模組名稱
            group: null,
            // include.rootPath
            includePath: null,
            // 要注入的全域變數
            variable: {},
            // 模板中會用到路徑資訊
            path: {},
        };

        // 文本內容
        this.content = '';

        // fn 的內文(要解析的目標)
        this.fnContext;

        this.nodeList;

        // 要注入的模組
        this.injectModules;
        //------------------
        this._init(content, options);
    }
    //----------------------------
    _init(content, options) {
        // debugger;

        this.systemInfo = $SystemInfo.getInfo();

        if (typeof content == 'string') {
            this.content = content;
        } else {
            throw new TypeError(`$template() content typeError`);
        }

        if (/nodejs/.test(this.systemInfo.system)) {
            // node.js 預設用 async
            this.options.async = true;
        } else {
            // browser 預設用 sync
            this.options.async = false;
        }

        Object.assign(this.options, options);
    }
    //----------------------------
    setOptions(k, v) {
        let options = {};

        if (typeof k == "string") {
            options[k] = v;
        } else {
            Object.assign(options, k);
        }

        for (let k in options) {
            let set = options[k];
            switch (k) {
                case "path":
                    this.setPath(set);
                    break;
                case "variable":
                    this.setVariable(set);
                    break;
                case "includePath":
                    this.setIncludepath(set);
                    break;
                case "group":
                    this.setGroup(set);
                    break;
                case "bind":
                    this.setBind(set);
                    break;
                case "async":
                    this.setAsync(set);
                    break;
            }
        }
    }

    // 設定模板內的路徑資訊
    setPath(name, path) {
        const $path = this.options.path;

        if (typeof name == 'string') {
            $path[name] = path;
        } else {
            Object.assign($path, name);
        }
    }

    // 設定 include.rootPath
    setIncludepath(includePath) {
        this.options.includePath = includePath;
    }

    // 解析方法採用何種方式
    setAsync(async) {
        this.options.async = !!async;
    }

    // 綁定模板內的對象
    setBind(obj) {
        this.options.bind = obj;
    }

    // 設定 injectMode 的分組
    setGroup(group) {
        this.options.group = group;
    }

    // 設定模板內的全域變數
    setVariable(k, v) {
        const variable = this.options.variable;
        variable[k] = v;
    }

    //----------------------------
    // test
    testGetNodeList() {
        debugger;

        // 分析文本
        // 最麻煩的地方
        let nodeList = $TagTools.getNodeListSync(content, this);
        return nodeList;
    }

    // test
    testGetContext() {
        debugger;

        // 分析文本
        // 最麻煩的地方
        let nodeList = $TagTools.getNodeListSync(content, this);

        let fnCommand = '';

        // 困難地方
        nodeList.forEach(function (node) {
            // this.fnCommand += node.printCommand(this.SCRIPTS);
            fnCommand += node.printCommand();
        }, this);
        return fnCommand;
    }
    //----------------------------
    main(data) {
        debugger;

        Object.assign(this.data, data);

        // 取得所需模组
        this._getInjectModules();

        let async = !!this.options.async;

        if (async) {
            let p = this._main();
            return p;
        } else {
            return this._mainSync();
        }
    }
    //----------------------------
    getModules() {
        const res = this.injectModules || (this._getInjectModules());

        return res;
    }
    //----------------------------
    // 取得要注入的模組
    _getInjectModules() {
        debugger;

        const moduleGroup = this.options.group;

        const variable = Object.assign({}, this.options.variable);

        // 處理 includePath
        const path = Object.assign({}, this.options.path);

        if (path["root"] != null) {
            throw new Error("cant override path.root");
        } else {
            path["root"] = this.options.includePath || this.systemInfo.includeRootPath;

        }

        const async = this.options.async;

        const fileSys = this.systemInfo.fileSystem;
        const pathSys = this.systemInfo.pathSystem;
        const bind = this.options.bind;
        //------------------

        this.injectModules = {
            out: null,
            filter: null,
            fun: null,
            path: path,
            variable: variable,
            async: async,
            fileSys: fileSys,
            pathSys: pathSys,
            bind: bind
        };

        const module = this.injectModules
        //------------------

        $OutputModule.getModule(this, moduleGroup, module, 'out');
        $Filter.getModule(this, moduleGroup, module, 'filter');
        $FunctionModule.getModule(this, moduleGroup, module, 'fun');
        //------------------

        debugger;
        module.isAsync = (function () {
            return this.async;
        }).bind(module);
    }
    //----------------------------
    async _main() {
        debugger;

        if (this.fnContext == null) {
            // 分析文本
            // 最麻煩的地方
            this.nodeList = await $TagTools.getNodeList(this, content);

            debugger;

            // 把文本轉成函式內容
            // this._getCommand(this.nodeList);
        }
        return this.nodeList;

        let fn = this._generatorRenderFunction();

        // 執行函式
        let res = await this._render(fn);

        return res;
    }

    _mainSync() {
        debugger;

        if (this.fnContext == null) {

            // 分析文本
            // 最麻煩的地方
            this.nodeList = $TagTools.getNodeListSync(this, this.content);

            debugger;

            // 把文本轉成函式內容
            // this._getCommandSync(this.nodeList);
        }

        return this.nodeList;

        let fn = this._generatorRenderFunction();

        // 執行函式
        let res = this._renderSync(fn);

        return res;
    }
    //----------------------------
    _getCommandSync(nodeList) {
        debugger;

        let fnCommand = '';
        let variableText = '';

        // 困難地方
        nodeList.forEach(function (node) {
            // this.fnCommand += node.printCommand(this.SCRIPTS);
            fnCommand += node.printCommand();
        }, this);



        fnCommand = `
            'use strict';
            debugger;

            const Data = $$$data;
            const Output = $$$outputModule;
            const Fun = $$$funModule;
            const Filter = $$$filterModule;
            const Path = $$$pathData;
            const Variable = $$$variable;
            //------------------
            $$$data = undefined;
            $$$outputModule = undefined;
            $$$funModule = undefined;
            $$$filterModule = undefined;
            $$$pathData = undefined;
            $$$variable = undefined;
            //------------------
            ${fnCommand}
            //------------------

            return (Out.result());\n`;


        this.fnContext = fnCommand;
    }

    _getCommand(nodeList) {
        debugger;

        let fnCommand = '';
        let variableText = '';

        // 困難地方
        nodeList.forEach(function (node) {
            // this.fnCommand += node.printCommand(this.SCRIPTS);
            fnCommand += node.printCommand();
        }, this);

        fnCommand = `
            'use strict'

            //------------------
            return (async function(){
                debugger
                'use strict';

                const Data = $$$data;
                const Output = $$$outputModule;
                const Fun = $$$funModule;
                const Filter = $$$filterModule;
                const Path = $$$pathData;
                const Variable = $$$variable;
                //------------------
                $$$data = undefined;
                $$$outputModule = undefined;
                $$$funModule = undefined;
                $$$filterModule = undefined;
                $$$pathData = undefined;
                $$$variable = undefined;

                //------------------
                ${fnCommand}
                //------------------

                return (Out.result());\n;
            }).call(this)`;

        this.fnContext = fnCommand;
    }


    //----------------------------
    // 創造 function
    _generatorRenderFunction() {
        debugger;

        let fn;
        try {
            debugger;
            fn = new Function('$$$data',
                '$$$pathData',
                '$$$outputModule',
                '$$$funModule',
                '$$$filterModule',
                '$$$variable',
                this.fnContext);
        } catch (error) {
            console.log(this.fnContext);
            throw new Error(`build template error(${String(error)})`);
        }
        return fn;
    }
    //----------------------------
    _renderSync(fn) {

        debugger;
        const M = this.injectModules;

        const outputModule = M['output'];
        const funModule = M['fun'];
        const filterModule = M['filter'];
        const path = M['path'];

        const variable = Object.assign(this.options.variable);
        const bindObj = this.options.bind;

        //----------------------------
        let htmlContent;

        try {
            htmlContent = fn.call(bindObj,
                this.data,
                path,
                outputModule,
                funModule,
                filterModule,
                variable);
        } catch (error) {
            throw new Error(`run template error(${String(error)}) => (${fn.toString()})`);
        }
        return htmlContent;
    }

    _render(fn) {
        debugger;

        const M = this.injectModules;

        const outputModule = M['output'];
        const funModule = M['fun'];
        const filterModule = M['filter'];
        const path = M['path'];

        const variable = Object.assign(this.options.variable);
        const bindObj = this.options.bind;

        //----------------------------
        let promise;

        try {
            promise = fn.call(bindObj,
                this.data,
                path,
                outputModule,
                funModule,
                filterModule,
                variable);
        } catch (error) {
            throw new Error(`run template error(${String(error)}) => (${fn.toString()})`);
        }
        return promise;
    }

}


module.exports = RenderFactory;
GModules["RenderFactory"] = RenderFactory;
